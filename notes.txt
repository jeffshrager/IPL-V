Hint: Look for /14 -- that's where the parser failed. Something went wrong just above that!

   (ARG0)=({9+34911|||9+34888})
!![RUN]::@341+ >>>>>>>>>> {P050R120::P50+34237|11|W0|P50+34238}
!![RUN]::@342+ >>>>>>>>>> {P050R130::P50+34238|11|W1|P50+34239}
!![RUN]::@343+ >>>>>>>>>> {P050R140::P50+34239||J64|P50+34240 [INSERT MEX UNDER OLD HEAD.;]}
!![RUN]::>>>>>>>>>> Calling J64 [INSERT (0) AFTER SYMBOL IN (1)]
   (SYMBOL-OR-CELL LIST-CELL-OR-NAME)=({L+34905|02|0|9+34909}
                                       {*12||*12+34884|0})
!![RUN]::@344+ >>>>>>>>>> {P050R190::P50+34240|11|W0|P50+34241}
!![RUN]::@345+ >>>>>>>>>> {P050R200::P50+34241|10|Q15|P50+34242}

J64 isn't inserting ... or whatever it's supposed to do!

+---------------------------------------------------------------------+
| {/014D000::/14||/14+76048|0 [/11 DUMMY CHARACTER SYMBOL;]}          |
+---------------------------------------------------------------------+
| {9+76151|21|/14|9+76168}                                            |
| {9+76168||9+76151|9+76153}                                          |
| {9+76153|21|9+76152|9+76155}                                        |
| {9+76155|21|9+76154|9+76157}                                        |
| {9+76157|21|9+76156|9+76159}                                        |
| {9+76159|21|9+76158|9+76161}                                        |
| {9+76161|21|9+76160|9+76163}                                        |
| {9+76163|21|9+76162|9+76165}                                        |
| {9+76165|21|9+76164|9+76167}                                        |
| {9+76167|21|9+76166|0}                                              |
+---------------------------------------------------------------------+

I think I fucked whatever J6x it is that puts the chars in these cell symbs.

====

(What we're working through at the moment, to remind ourselves.)

## The H0 cleanup problem

There is a running issue about Jfns popping off things from H0, or
not. Some do, some don't, it's sort of assumed tha they do unless
stated otherwise ... or something. It seems that all JFns are supposed
to remove their inputs, e.g., p.10: "...it is understood from the
definition of TEST that J2 will remove both (0) and (1) from HO."

We get to situations like this where there's nothing left on the H0
stack!

```
!![RUN]::>>>>>>>>>> Calling J155 [Print line] (No Args)
BAD EXPRESSION   K51K51|14I+27707Q+27792K52=+27927K51-+27915|14V+27897Q+27792K52
!![RUN]::@466- >>>>>>>>>> {X001R320::X1+28068|40|H0|X1+28069}
!![RUN]::@467- >>>>>>>>>> {X001R330::X1+28069||J15|X1+28070}
!![RUN]::>>>>>>>>>> Calling J15 [ERASE ALL ATTRIBUTES OF (0)]
   (ARG0)=(NIL)
!![JFNS]::J15 clearing the dl of NIL (NIL)
```

Someplace around @368 H0 seems to get over-popped. I think this expects
the name of the list ("*101") but I'm not sure. The last time we see
that in H0+ is @368:

```
!![RUN]::@368+ >>>>>>>>>> {M079R030::M79+29137||J157|J8 [        ENTER IT, DISCARD (0).|]}
   H0={(000D030::(+30229||K51|0} ++ ("*101")
   W0={W0|||} ++ ("W0-empty")
   W1={W1|||} ++ ("W1-empty")
   W2={W2|||} ++ ("W2-empty")
!![RUN]::>>>>>>>>>> Calling J157 [ENTER DATA TERM (0) LEFT-JUSTIFIED]
   (A0)=({(000D030::(+30229||K51|0})
!![JFNS]::J157 called on {(000D030::(+30229||K51|0}
!![JFNS]::Print buffer is now:
"BAD EXPRESSION   K51                                                            "
   H0="*101" ++ NIL
   W0={W0|||} ++ ("W0-empty")
   W1={W1|||} ++ ("W1-empty")
   W2={W2|||} ++ ("W2-empty")
!![RUN]::>>>>>>>>>> Calling J8 [RESTORE H0] (No Args)
   H0=NIL ++ NIL
   W0={W0|||} ++ ("W0-empty")
   W1={W1|||} ++ ("W1-empty")
   W2={W2|||} ++ ("W2-empty")
```

Something weird is going on with the restores (J8). If you look at the
M79 code it pushes and pops H0 itself, so the J8 restore seems like
over-popping, but someone ahead of all this might have over-popped.

But there's a proir problem of why where in this error reporting code
to begin with, because the expression that it's trying to P50
translate to a tree representation is perfectly fine, so, even tough
the error reporting is somehow broken, there's a high-up problem
(which might also be due to an over-agreesive stack pop higher up, but
the problem isn't showing up until deep in the error reporting.)

## The character/string/symbol/name mess.

There are a lot of issues around string handling, esp. in the single
character case (which the translator uses a lot!) Like, "A" is
represented as the name/symbol "A0", so the equiv. of IPL string-equal
(called, oddly enough: ipl-string-equal) has to do all sorts of
heuristic bending over backwards, as does the cell "getter" (<== ...)
and (cell< ...) which take either a string (cell name) or cell and
return a cell. This problem infuses the whole interpreter. See notes
about strings in the section on "Changes from standard (by the manual)
IPL-V", below. The way I've dealt with this is, in part, to explicitly
name the A, B, ... * . , ' etc in the code as A0 ... *0 ... '0 ... and
this seems to handle more cases, but there are places where it's
trying to do an equal test and it's not clear what's being equated.

